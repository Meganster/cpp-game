# Наследование классов
    Чтобы в дальнейшем нам не иметь проблем с системой подсчета очков, все объекты, создание которых требует запаса очков или разрушение
    которых приносит игроку очки, должны исполнять интрефейс Scorable (название не очень, согласен, но лучше я не придумал; открыт к предложениям).
    Заголовок данного интерфейса лежит в папке Classes/managers/Scorable.h
    
    На текущем этапе данный интерфейс должен исполнять только класс ребра.

# События
####    1. Запрос на добавление ребра: AddEdgeRequest
        Обработка данного события:
            1) Данный запрос будет ловиться менеджером дерева. 
            2) Менеджер дерева будет проверять у менеджера очков, достаточно ли у игрока очков, чтобы создать запрашиваемый объект.
            3) Если очков достаточно, запрашиваемый объект будет создан.
            
        Содержание события: есть два варинта содержания события:
            1) Событие содержит указатель на созданный но еще не сохраненный (то есть не подцепленный к сцене объект ребра).
                Достоинства варианта:   прост в реализации, позволяет одинаково работать с различными классам ребер 
                                        (если они у нас будут).
                Недостатки варианта:    возможно, будет оверхед при создании, а затем отбраковке ребер.                
                
            2) Событие содержит указатель на объект фабрику по производству ребер и указатели на пару вершин.
                Объект фабрика, будучи инициализирован парой вершин, должен давать оценку в очках стоимости производства
                ребра, а также при необходимости создавать сам объект ребра.
                
                Достоинства варианта:   уменьшение оверхеда, большая универсальность подхода, баллы по проекту за использование 
                                        паттернов.
                Недостатки варианта:    бОльшая сложность реализации
        
##    2. Запрос на добавление узла: AddNodeRequest
        Обработка данного события:
            Та же, что и для предыдущего события.
        
        Содержание события: есть два варианта содержания события:
            1) Событие содержит указатель на вектор созданных, но не прикрепленных ребер.
            2) Событие содержит указатель на вектор базовых вершин, координаты новой вершины и указатель на объект фабрику.
            
##    3. Событие удаления ребра: EdgeDeletedEvent
        Обработка данного события: 
            1) Событие ловится менеджером дерева.
            2) Менеджер очков получает информацию о количестве очков, которые нужно зачислить на счет игрока.
            3) Менеджером дерева производится удаление ребра.
            
        Содержание события: указатель на объект ребра.
        
## Резюме
    Я думаю, что в приведенных классах событий целесообразно использовать объект фабрики по следующим причинам:
        1) Относительная простота реализации: класс фабрики может быть выполнен в фоме синглтона, в 
            который заносится объет для клонирования. В этом случае не придется создавать по фабрике для разных типов
            ребер.
        2) Удобство использования: для создания ребер не придется создавать избыточные объекты, которые потом могут быть
            отбракованы. Код станет чище. Кроме того, если будет принят вариант с синглтоном, необходимость в его передаче
            вообще отпадает, так как он доступен любому объекту в течение всего времени исполнения программы.
        3) Баллы за паттерны очень сильно греют душу)
            
    